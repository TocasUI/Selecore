// Generated by CoffeeScript 2.0.0-beta4
// 主要的選擇器函式。
var $selector;

$selector = function(selector, context) {
  var nodes, ref, tag;
  nodes = [];
  // 如果選擇器是文字，但是是標籤（如：`<div>`）就建立新的元素
  if (typeof selector === 'string' && selector[0] === '<') {
    tag = selector.match(/<(.*)\/>|<(.*)>/);
    nodes = [document.createElement((ref = tag[1]) != null ? ref : tag[2])];
  // 如果選擇器是一般的文字，就選取元素。
  } else if (typeof selector === 'string' && context === void 0) {
    document.querySelectorAll(selector).forEach(function(element) {
      return nodes.push(element);
    });
  // 如果選擇器有上下文選擇器，就透過選擇器找出上下文元素。
  } else if (typeof context === 'string') {
    nodes = $selector(selector).find(context).toArray();
  // 如果選擇器是 NodeList 就轉換成元素陣列然後取出來接著繼續。
  } else if (selector instanceof NodeList) {
    selector.forEach(function(element) {
      return nodes.push(element);
    });
  // 如果選擇器是陣列，就當作是元素陣列，取出來然後繼續。
  // 或傳入的是一個選擇器，就取出裡面的元素然後繼續。
  } else if (Array.isArray(selector) || (selector != null ? selector.isSelector : void 0) === true) {
    nodes = nodes.concat(selector);
  // 如果是單個 DOM 元素，就放入選擇器然後繼續。
  } else if (selector instanceof HTMLElement) {
    nodes = [selector];
  }
  // 保存目前的選擇器文字與上下文選擇器文字。
  nodes.selector = typeof selector === 'string' ? selector : null;
  nodes.context = typeof context === 'string' ? context : null;
  // 將自訂的選擇器方法插入到節點陣列中，這樣才能夠串連使用。
  Object.defineProperties(nodes, $selector.fn);
  // 將節點陣列標註為是選擇器，這樣才能判斷傳入的是不是我們自己的選擇器。
  Object.defineProperty(nodes, 'isSelector', {
    value: true
  });
  return nodes;
};

// 函式鏈。
$selector.fn = {};

// Get

// 取得選擇器內的指定元素，並且回傳一個 DOM 元素而非選擇器。
$selector.fn.get = {
  value: function(index = 0) {
    return this[index];
  }
};

// ToArray

// 將選擇器轉換成帶有節點的一般陣列。
$selector.fn.toArray = {
  value: function() {
    var array;
    array = [];
    this.forEach(function(element) {
      return array.push(element);
    });
    return array;
  }
};

// Each

// 遍歷整個選擇器陣列。
$selector.fn.each = {
  value: function(callback) {
    this.forEach(function(element, index) {
      return callback.call(element, element, index);
    });
    return this;
  }
};

// CollectSwap

// 將收集到的元素替換掉目前選擇器內的所有元素。
$selector.fn.collectSwap = {
  value: function(callback) {
    var collection, newSelector;
    collection = [];
    this.each(function(element, index) {
      var result;
      result = callback.call(element, element, index);
      if (result === void 0 || result === null) {
        return;
      }
      if (result instanceof NodeList) {
        return result.forEach(function(el) {
          return collection.push(el);
        });
      } else if (Array.isArray(result)) {
        return collection = collection.concat(result);
      } else {
        if (collection.indexOf(result) === -1) {
          return collection.push(result);
        }
      }
    });
    // 透過 Set 型態移除重複的節點。
    collection = new Set(collection);
    // 然後將 Set 轉換成陣列，建立新的選擇器。
    newSelector = $selector([...collection]);
    // 保存選擇器之前的所有節點。
    Object.defineProperty(newSelector, 'prevObject', {
      value: this
    });
    // 回傳這個新的選擇器。
    return newSelector;
  }
};

// Eq

// 取得選擇器的指定元素，然後繼續回傳僅帶有該元素的選擇器。
$selector.fn.eq = {
  value: function(index) {
    return $selector(this.get(index));
  }
};

// Parent

// 回傳元素的父元素選擇器。
$selector.fn.parent = {
  value: function() {
    return this.collectSwap(function() {
      return this.parentNode;
    });
  }
};

// Closest

// 回傳最接近指定的父元素選擇器。
$selector.fn.closest = {
  value: function(selector) {
    return this.collectSwap(function() {
      return this.closest(selector);
    });
  }
};

// Find

// 在目前元素中搜尋指定元素並回傳其選擇器。
$selector.fn.find = {
  value: function(selector) {
    return this.collectSwap(function() {
      return this.querySelectorAll(selector);
    });
  }
};

// Wrap

// 將元素用指定元素包覆起來。
$selector.fn.wrap = {
  value: function(element) {
    return this.each(function() {
      if (this.nextSibling) {
        this.parentNode.insertBefore(element, this.nextSibling);
      } else {
        this.parentNode.appendChild(element);
      }
      return element.appendChild(this);
    });
  }
};

// Append

// 將元素插入在目前選擇器元素的內部最後面。
$selector.fn.append = {
  value: function(element) {
    return this.each(function() {
      return this.appendChild(element);
    });
  }
};

// AppendTo

// 將目前選擇器元素插入到指定元素的內部最後面。
$selector.fn.appendTo = {
  value: function(selector) {
    return this.each(function() {
      return $selector(selector).append(this);
    });
  }
};

// Prepend

// 將元素插入在目前選擇器元素的內部最前面。
$selector.fn.prepend = {
  value: function(element) {
    return this.each(function() {
      if (this.parentNode !== null) {
        return this.parentNode.insertBefore(element, this.parentNode.firstChild);
      }
    });
  }
};

// PrependTo

// 將目前選擇器元素插入到指定元素的內部最前面。
$selector.fn.prependTo = {
  value: function(selector) {
    return this.each(function() {
      return $selector(selector).prepend(this);
    });
  }
};

// Remove

// 將選擇器元素從頁面上中移除。
$selector.fn.remove = {
  value: function() {
    return this.each(function() {
      var ref;
      return (ref = this.parentNode) != null ? ref.removeChild(this) : void 0;
    });
  }
};

// Is

// 選擇一些元素，然後用來比對目前的選擇器元素是否在這群當中。
$selector.fn.is = {
  value: function(selector) {
    var compareElements, isInElements;
    compareElements = document.querySelectorAll(selector);
    isInElements = false;
    this.each(function() {
      return compareElements.forEach(function(compareElement) {
        if (this === compareElement) {
          return isInElements = true;
        }
      }, this);
    });
    return isInElements;
  }
};

// Slice

// 替元素陣列進行切分。
$selector.fn.slice = {
  value: function(from, to) {
    return $selector(this.toArray().slice(from, to));
  }
};

// Children

// 取得容器裡的第一層子節點。
$selector.fn.children = {
  value: function(selector) {
    return this.collectSwap(function() {
      return this.querySelectorAll(selector != null ? `:scope > ${selector}` : ':scope > *');
    });
  }
};

// Next

// 下一個元素。
$selector.fn.next = {
  value: function() {
    return this.collectSwap(function() {
      return this.nextElementSibling;
    });
  }
};

// Prev

// 上一個元素。
$selector.fn.prev = {
  value: function() {
    return this.collectSwap(function() {
      return this.previousElementSibling;
    });
  }
};

// NextAll

// 這個元素之後的所有同階層元素。
$selector.fn.nextAll = {
  value: function(selector) {
    return this.collectSwap(function() {
      var $children, $parent, $self, index;
      $self = $selector(this);
      $parent = $self.parent();
      $children = selector != null ? $parent.find(`:scope > ${selector}`) : $parent.find(':scope > *');
      index = $self.index();
      return $children.slice(index + 1);
    });
  }
};

// PrevAll

// 這個元素之前的所有同階層元素。
$selector.fn.prevAll = {
  value: function(selector) {
    return this.collectSwap(function() {
      var $children, $parent, $self, index;
      $self = $selector(this);
      $parent = $self.parent();
      $children = selector != null ? $parent.find(`:scope > ${selector}`) : $parent.find(':scope > *');
      index = $self.index();
      return $children.slice(0, index);
    });
  }
};

// AddBack

// 在目前的選擇器節點陣列中加上先前選擇的所有節點。
$selector.fn.addBack = {
  value: function() {
    if (this.prevObject) {
      this.prevObject.toArray().forEach((element) => {
        return this.push(element);
      });
    }
    return this;
  }
};

// Index

// 該元素在容器內的索引。
$selector.fn.index = {
  value: function() {
    var index, node;
    node = this.get(0);
    index = 0;
    if (node == null) {
      return -1;
    }
    while ((node = node.previousElementSibling)) {
      index++;
    }
    return index;
  }
};

// Attr

// 取得或是建立新的標籤到目前的選擇器元素。
$selector.fn.attr = {
  value: function(name, value) {
    var ref;
    // 如果有 value 就設置簡單鍵值資料。
    if (value !== void 0) {
      return this.each(function() {
        return this.setAttribute(name, value);
      });
    // 如果傳入的是物件就設置多重資料。
    } else if (typeof name === 'object') {
      return this.each(function() {
        var key, results;
        results = [];
        for (key in name) {
          results.push(this.setAttribute(key, name[key]));
        }
        return results;
      });
    } else {
      return (ref = this.get()) != null ? ref.getAttribute(name) : void 0;
    }
  }
};

// RemoveAttr

// 移除目前選擇器元素的指定標籤。
$selector.fn.removeAttr = {
  value: function(name) {
    return this.each(function() {
      return this.removeAttribute(name);
    });
  }
};

// AddClass

// 在目前選擇器元素插入新的樣式類別名稱。
$selector.fn.addClass = {
  value: function(names) {
    return this.each(function() {
      return DOMTokenList.prototype.add.apply(this.classList, names.split(' '));
    });
  }
};

// RemoveClass

// 移除目前選擇器元素的指定樣式類別。
$selector.fn.removeClass = {
  value: function(names) {
    return this.each(function() {
      return DOMTokenList.prototype.remove.apply(this.classList, names.split(' '));
    });
  }
};

// ToggleClass

// 切換目前選擇器元素的樣式。
$selector.fn.toggleClass = {
  value: function(names) {
    return this.each(function() {
      return names.split(' ').forEach(function(name) {
        return this.classList.toggle(name);
      }, this);
    });
  }
};

// HasClass

// 回傳選擇器元素是否帶有指定樣式類別，是布林值。
$selector.fn.hasClass = {
  value: function(name) {
    var ref;
    return (ref = this.get(0)) != null ? ref.classList.contains(name) : void 0;
  }
};

// CSS

// 將選擇器元素套用指定的 CSS 樣式。
$selector.fn.css = {
  value: function(name, value) {
    var key;
    // 有 name 也有 value 就設置樣式。
    if (typeof name === 'string' && value !== void 0) {
      return this.each(function() {
        return this.style[name] = value;
      });
    // 有 name 但沒有 value 就取得樣式。
    } else if (typeof name === 'string' && value === void 0) {
      if (this.get() != null) {
        return document.defaultView.getComputedStyle(this.get(), null).getPropertyValue(name);
      } else {
        return null;
      }
    // 有 name 但他是 object，就設置多重樣式。
    } else if (typeof name === 'object') {
      for (key in name) {
        this.each(function() {
          return this.style[key] = name[key];
        });
      }
      return this;
    }
  }
};

// On

// 綁定並註冊一個事件監聽器。
$selector.fn.on = {
  value: function(events, handler, options) {
    if (events === 'animationend') {
      events = 'webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend';
    }
    return this.each(function() {
      if (this.addEventListener === void 0) {
        return;
      }
      if (this.$events === void 0) {
        this.$events = {};
      }
      return events.split(' ').forEach(function(eventName) {
        // 如果事件還沒在這個物件內產生過，就初始化一個事件結構。
        if (this.$events[eventName] === void 0) {
          this.$events[eventName] = {
            binded: false,
            list: []
          };
        }
        // 如果這個事件還沒被註冊過。
        if (this.$events[eventName].binded === false) {
          // 建立一個管理多個事件的事件管理處理程式。
          this.addEventListener(eventName, function(event) {
            // 如果該事件已經被移除則停止後續的反應。
            if (this.$events[eventName] === void 0) {
              return;
            }
            // 將被觸發的事件裡面的所有處理程式全部呼叫一次。
            return this.$events[eventName].list.forEach(function(item, index) {
              item.func.call(this, event);
              // 如果這個程式只能被呼叫一次就在處理程式呼叫後移除。
              if (item.once === true) {
                return this.$events[eventName].list.splice(index, 1);
              }
            }, this);
          });
          // 將對應的事件監聽器設置為已綁定。
          this.$events[eventName].binded = true;
        }
        // 將新的事件處理程式註冊到事件清單中。
        return this.$events[eventName].list.push({
          func: handler,
          once: options != null ? options.once : void 0
        });
      }, this);
    });
  }
};

// One

// 綁定一次性的事件監聽器，當被觸發之後就會被移除。
$selector.fn.one = {
  value: function(events, handler) {
    return this.each(function() {
      return $selector(this).on(events, handler, {
        once: true
      });
    });
  }
};

// Off

// 註銷事件監聽器。
$selector.fn.off = {
  value: function(events, handler) {
    return this.each(function() {
      return events.split(' ').forEach((eventName) => {
        if (this.$events === void 0) {
          return;
        }
        if (this.$events[eventName] === void 0) {
          return;
        }
        if (handler === void 0) {
          this.$events[eventName].list = [];
        }
        return this.$events[eventName].list.forEach((item, index) => {
          if (handler === item.func) {
            return this.$events[eventName].list.splice(index, 1);
          }
        });
      }, this);
    });
  }
};

// Text

// 變更或取得選擇器元素的內容文字。
$selector.fn.text = {
  value: function(text) {
    var ref;
    if (text !== void 0) {
      return this.each(function() {
        return this.innerText = text;
      });
    } else {
      return (ref = this.get()) != null ? ref.innerText : void 0;
    }
  }
};

// Val

// 變更或取得選擇器元素的值。
$selector.fn.val = {
  value: function(value) {
    var ref;
    if (value !== void 0) {
      return this.each(function() {
        return this.value = value;
      });
    } else {
      return (ref = this.get()) != null ? ref.value : void 0;
    }
  }
};

// HTML

// 變更或取得選擇器元素的 HTML。
$selector.fn.html = {
  value: function(html) {
    var ref;
    if (html !== void 0) {
      return this.each(function() {
        return this.innerHTML = html;
      });
    } else {
      return (ref = this.get()) != null ? ref.innerHTML : void 0;
    }
  }
};

// Empty

// 將選擇器元素的內容清除，例如值或文字。
$selector.fn.empty = {
  value: function() {
    return this.each(function() {
      if (this.value !== void 0) {
        this.value = null;
      }
      if (this.innerHTML !== void 0) {
        this.innerHTML = null;
      }
      if (this.innerText !== void 0) {
        return this.innerText = null;
      }
    });
  }
};

// Prop

// 變更或取得選擇器元素的屬性，例如 `.src`、`.width`。
$selector.fn.prop = {
  value: function(name, value) {
    var key, ref;
    // 有 name 也有 value 就設置屬性。
    if (typeof name === 'string' && value !== void 0) {
      return this.each(function() {
        return this[name] = value;
      });
    // 有 name 但沒有 value 就取得屬性。
    } else if (typeof name === 'string' && value === void 0) {
      return (ref = this.get()) != null ? ref[name] : void 0;
    // 有 name 但他是 object，就設置多重屬性。
    } else if (typeof name === 'object') {
      for (key in name) {
        this.each(function() {
          return this[key] = name[key];
        });
      }
      return this;
    }
  }
};

// Data

// 在選擇器元素中存放資料，類似 Attr 但頁面不可見。
$selector.fn.data = {
  value: function(name, value) {
    var key, ref, ref1;
    // 有 name 也有 value 就設置資料。
    if (typeof name === 'string' && value !== void 0) {
      return this.each(function() {
        if (this.$data === void 0) {
          this.$data = {};
        }
        return this.$data[name] = value;
      });
    // 有 name 但沒有 value 就取得資料。
    } else if (typeof name === 'string' && value === void 0) {
      return (ref = this.get()) != null ? (ref1 = ref.$data) != null ? ref1[name] : void 0 : void 0;
    // 有 name 但他是 object，就設置多重樣式。
    } else if (typeof name === 'object') {
      for (key in name) {
        this.each(function() {
          if (this.$data === void 0) {
            this.$data = {};
          }
          return this.$data[key] = name[key];
        });
      }
      return this;
    }
  }
};
